---
title: "Data Science for Political Science"
author: "Instructor: Katherine McCabe"
site: bookdown::bookdown_site
documentclass: book
output:
  bookdown::gitbook:
    dev: svglite
    css: css/style.css
    split_by: section
    split_bib: true
    number_sections: true
---

# Course Notes

This document will include important links and course notes for 01:790:391:01: Data Science for Political Science.

  - This site will be updated throughout the semester with new content. 
  - The Canvas modules will provide links to the relevant sections to review for a given week of the course.
  - The primary text for the course is [Quantitative Social Science: An Introduction](https://qss.princeton.press/qss-an-introduction/) by Kosuke Imai. We will refer to this as QSS in the notes.
  - This is a new and living document. If you spot errors or have questions or suggestions, please email me at k.mccabe@rutgers.edu or post to the course Piazza site.
  - Occasionally the notes are updated with embedded video explainers of the code in different sections. A list of these is [here](https://www.youtube.com/watch?v=80tbdiWuljc&list=PLx0unV_UpWcXDDBO2Bg5Cf6N4m0_LKULl&ab_channel=kt2mccabe).

<!-- If you need PDF output, uncomment bookdown::pdf_book above in YAML. You will need a LaTeX installation, e.g., https://yihui.name/tinytex/ -->

<!-- Instructions: https://ontheline.trincoll.edu/bookdown.html -->


## What have I signed up for?


First: What is Data Science?

  - Data Science involves a combination of math/statistics and programming/coding skills, which, for our purposes, we will combine with social science knowledge.
    + [Drew Conway](http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram) has a nice venn diagram of how these different skill sets intersect.
    + Note: This course will not assume prior familiarity with data science in general or coding, specifically. For those brand new to data science, the idea of learning to code may seem intimidating, but anyone can succeed with a bit of patience and an open mind.

![](images/venn.png)
  
Next: What is political science?
  
  - The science of politics, of course! Politics focuses on studying governance and the distribution of power in society, broadly conceived. 
      + How else might you define politics and political science? What do we study in political science?


### Data Science Can Help Social Scientists


***Example: Mapping poverty using mobile phone and satellite data***

Researchers used modern data sources, including mobile phone data, as a way to ***predict*** and ***describe*** poverty in different geographic regions. These tools helped social scientists come up with methods that are much more cost-effective and efficient, but still as accurate as traditional methods for this type of measurement.

  - How might measures of global poverty be useful to political scientists?


![](images/blum.jpg){width=90%}

*[Steele et al. 2017](https://royalsocietypublishing.org/doi/full/10.1098/rsif.2016.0690): Poverty is one of the most important determinants of adverse health outcomes globally, a major cause of societal instability and one of the largest causes of lost human potential. Traditional approaches to measuring and targeting poverty rely heavily on census data, which in most low- and middle-income countries (LMICs) are unavailable or out-of-date. Alternate measures are needed to complement and update estimates between censuses. This study demonstrates how public and private data sources that are commonly available for LMICs can be used to provide novel insight into the spatial distribution of poverty.* 


***Social Science Goals***

We have several goals in social science. Here are four that data science can help us pursue:

  - **Describe** and measure
      + Has the U.S. population increased?
  - **Explain**, evaluate, and recommend (study of causation)
      + Does expanding Medicaid improve health outcomes?
  - **Predict**
      + Who will win the next election?
  - **Discover**
      + How do policies diffuse across states?

What are other examples of these goals?



Note: In this course, we are exploiting the benefits of quantitative data to help achieve goals of social science. However, quantitative data have their shortcomings, too. We will also discuss the limitations of various applications of social science data, and we encourage you to always think critically about how we are using data.

### Course Goals

This course will provide you with a taste of each of these social science goals, and how the use of data can help achieve these goals. By the end of the course, you should be able to

  - Provide examples of how quantitative data may be used to help answer social science research questions.
  - Compare and contrast the goals of description, causation, prediction, and discovery in social science research.
  - Use the programming language R to import and explore social science data and conduct basic statistical analyses.
  - Interpret and describe visual displays of social science data, such as graphs and maps. 
  - Develop your own analyses and visualizations to understand social science phenomena.


If you are someone that loves data, we hope you will find this course engaging. If you are someone who loathes or finds the idea of working with data and statistics alarming, we hope you keep an open mind. We will meet you where you are. This course will not assume knowledge of statistical software, and there will be plenty of opportunities to ask questions and seek help from classmates and the instructor throughout the semester. 

The first section of course will walk people through how to use the statistical program-- R-- that we will employ this semester. 

***Will this course help me in the future?***

Even if you do not plan on becoming a social scientist or a data scientist, an introduction to these skills may prove helpful throughout your academic and professional careers.

  - To become an informed consumer of news articles and research involving quantitative analyses.
  - To practice analytical thinking to make informed arguments and decisions.
  - To expand your toolkit for getting a job that may involve consuming or performing some data analysis, even if that is not the traditional role.
    + Example: Journalism- [How 5 Data Dynamos Do Their Jobs](https://www.nytimes.com/2019/06/12/reader-center/data-reporting-spreadsheets.html) 



## Setup in R {#rsetup}

**Goal**

By the end of the first week of the course, you will want to have R and RStudio installed on your computer (both free) and feel comfortable using R as a calculator.

R is an application that processes the R programming language in a statistical computing environment. RStudio is also an application, which serves as a user interface that makes working in R easier. We will primarily open and use RStudio to work with R.   

In other classes, you may come across Stata, SPSS, Excel, or SAS, which are programs that also conduct data analysis. R has the advantage of being free and open-source. Even after you leave the university setting, you will be able to use R/RStudio for free. As an open-source program, it is very flexible, and a community of active R/RStudio users is constantly adding to and improving the program.   


**R and RStudio Installation**

This content follows and reinforces QSS 1.3. Additional resources are also linked below.

  - This [video](http://www.youtube.com/embed/ulIv0NiVTs4?rel=0) from Professor Christopher Bail explains why many social scientists use R and describes the R and RStudio installation process. This involves
    1. Going to [cran](https://cran.r-project.org/), select the link that matches your operating system, and
then follow the installation instructions, and 
    2. Visiting [RStudio](http://www.rstudio.com/) and follow the download and installation instructions. R is the statistical software and programming language used for analysis. RStudio provides a convenient user interface for running R code. 

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library("vembedr")
library(knitr)

embed_url("https://www.youtube.com/watch?v=ulIv0NiVTs4")
```


 

## First Time Working in R and RStudio

This next section provides a few notes on using R and RStudio now that you have installed it. In this section, we cover the following materials:

  - Using R as a calculator and assigning objects using `<-`
  - Setting your working directory and the `setwd()` function.
  - Creating and saving an R script

This section highlights important concepts from QSS chapter 1.

### Open RStudio

RStudio is an open-source and free program that greatly facilitates the use of R, especially for users new to programming. Once you have downloaded and installed R and RStudio, to work in R, all you need to do now is ***open RStudio*** (it will open R). It should look like this, though your version numbers will be different:

![](images/rconsole1.png)

**Note:** The first time you open RStudio, you likely only have the three windows above. We will want to create a fourth window by **opening an R script** to create the fourth window. 

  - To do this, in RStudio, click on File -> New -> R script in your computer's toolbar. This will open a blank document for text editing in the upper left of the RStudio window. We will return to this window in a moment.
      + You can alternatively click on the green + sign indicator in the top-left corner of the RStudio window, which should give you the option to create a new R script document.

Now you should have something that looks like this, similar to Figure 1.1. in QSS:

![](images/rconsole2.png)

  
  - The upper-left window has our script document that will contain code.
  - The lower-left window is the console. This will show the output of the code we run. We will also be able to type directly in the console.
  - The upper-right window shows the environment (and other tabs, such as the history of commands). When we load and store data in RStudio, we will see a summary of that in the environment.
  - The lower-right window will enable us to view plots and search help files, among other things.



### Using R as a Calculator

The *bottom left* window in your RStudio is the Console. You can type in this window to use R as a calculator or to try out commands. It will show the raw output of any commands you type. For example, we can try to use R as a calculator. Type the following in the Console (the bottom left window) and hit "enter" or "return" on your keyboard:

```{r}
5 + 3

5 - 3

5^2

5 * 3

5/3

(5 + 3) * 2
```

In the other RStudio windows, the upper right will show a history of commands that you have sent from the text editor to the R console, along with other items. The lower right will show graphs, help documents and other features. These will be useful later in the course.

### Working in an R Script

Earlier, I asked you to open an R script in the upper left window by doing File, then New File, then R Script. Let's go back to working in that window.

**Set your working directory `setwd()`**

(Almost) every time you work in RStudio, the first thing you will do is set your working directory. This is a designated folder in your computer where you will save your R scripts and datasets.

There are many ways to do this.

  - An easy way is to go to Session -> Set Working Directory -> Choose Directory. I suggest choosing a folder in your computer that you can easily find and that you will routinely use for this class. Go ahead and create/select it. 
  - Note: when you selected your directory, code came out in the bottom left Console window. This is the `setwd()` command which can also be used directly to set your working directory in the future.
  - If you aren't sure where your directory has been set, you can also type `getwd()` in your Console. Try it now


```{r, eval=F}
## Example of where my directory was
getwd()
```


If I want to  change the working directory, I can go to the top toolbar of my computer and use Session -> Set Working Directory -> Choose Directory or just type my file pathway using the `setwd()` below:

```{r, eval=FALSE}
## Example of setting the working directory using setwd().
## Your computer will have your own file path.
setwd("/Users/ktmccabe/Dropbox/Rutgers Teaching/")
```


**Saving the R Script**

Let's now save our R script to our working directory and give it an informative name. To do so, go to File, then Save As, make sure you are in the same folder on your computer as the folder you chose for your working directory.

Give the file an informative name, such as: "McCabeWeek1.R". Note: all of your R scripts will have the .R extension.


### Preparing your R script

Now that we have saved our R script, let's work inside of it. Remember, we are in the top-left RStudio window now.

  - Just like the beginning of a paper, you will want to title your R script. In R, any line that you start with a \# will not be treated as a programming command. You can use this to your advantage to write titles/comments. Below is a screenshot example of a template R script.
  - You can specify your working directory at the top, too. Add your own filepath inside `setwd()`

![](images/templateR.png)


  - Then you can start answering problems in the rest of the script.
  - Think of the R script as where you write the final draft of your paper. In the Console (the bottom-left window), you can mess around and try different things, like you might when you are taking notes or outlining an essay. Then, write the final programming steps that lead you to your answer in the R script. For example, if I wanted to add 5 + 3, I might try different ways of typing it in the Console, and then when I found out `5 + 3` is the right approach, I would type that into my script.


### Executing Commands in your R script

The last thing we will note in this initial handout is how to execute commands in your R script.

To run / execute a command in your R script (the upper left window), you can

  1. Highlight the code you want to run, and then hold down "command + return" on a Mac or "control + enter" on Windows
  2. Place your cursor at the end of the line of code (far right), and hit "command + return" on a Mac or "control + return" on Windows, or
  3. Do 1 or 2, but instead of using the keyboard to execute the commands, click "Run" in the top right corner of the upper-left window.

Try it: Type `5 + 3` in the R script. Then, try to execute `5 + 3`. It should look something like this:


![](images/rtemplate2.png)

After you executed the code, you should see it pop out in your Console:
```{r}
5 + 3
```

![](images/runningcode.png){width=90%}

Note: The symbol \# also allows for annotation behind commands or on a separate line. Everything that follows \# will be ignored by R. You can annotate your own code so that you and others can understand what each part of the code is designed to do.

```{r}
## Example
sum53 <- 5 + 3 # example of assigning an addition calculation
```

### Objects

Sometimes we will want to store our calculations as "objects" in R. We use `<-` to assign objects by placing it [to the left](https://www.youtube.com/watch?v=vLZA67L7gIo&ab_channel=BeyonceSasha1) of what we want to store. For example, let's store the calculation `5 + 3` as an object named `sum53`:

```{r}
sum53 <- 5 + 3
```

After we execute this code, `sum53 now stores the calculation. This means, that if we execute a line of code that just has `sum53`, it will output 8. Try  it:

```{r}
sum53
```

Now we no longer have to type `5 + 3`, we can just type `sum53`. For example, let's say we wanted to subtract 2 from this calculation. We could do:

```{r}
sum53 - 2
```

Let's say we wanted to divide two stored calculations:
```{r}
ten <- 5 + 5
two <- 1 + 1
ten / two
```

The information stored does not have to be numeric. For example, it can be a word, or what we would call a character string, in which case you need to use quotation marks.

```{r}
mccabe <- "professor for this course"
mccabe
```


*Note:* Object names cannot begin with numbers and no spacing is allowed. Avoid using special characters such as \% and \$, which have specific meanings in R. Finally, use concise and intuitive object names.

  - GOOD CODE: `practice.calc <- 5 + 3`
  - BAD CODE: `meaningless.and.unnecessarily.long.name <- 5 + 3`

While these are simple examples, we will use objects all the time for more complicated things to store (e.g., like full datasets!) throughout the course.

We can also store an array or "vector" of information using `c()`

```{r}
somenumbers <- c(3, 6, 8, 9)
somenumbers
```

**Importance of Clean Code**

Ideally, when you are done with your R script, you should be able to highlight the entire script and execute it without generating any error messages. This means your code is clean. Code with typos in it may generate a red error message in the Console upon execution. This can happen when there are typos or commands are misused.

For example, R is case sensitive. Let's say we assigned our object like before:
```{r}
sum53 <- 5 + 3
```

However, when we went to execute `sum53`, we accidentally typed `Sum53`:
```{r, error=TRUE}
Sum53
```

Only certain types of objects can be used in mathematical calculations. Let's say we tried to divide `mccabe` by 2:

```{r, error=TRUE}
mccabe / 2
```

A big part of learning to use R will be learning how to troubleshoot and detect typos in your code that generate error messages.

![](images/punctuation.png){width=80%}


## Assignment 1 

Below is an exercise that will demonstrate you are able to use R as a calculator and create R scripts, as well as locate important course platforms.

We will walk through this assignment together during class, but you are welcome to try to do this ahead of time on your own. You will submit, on Canvas, two documents prior to the deadline.

  - An R script (.R) file with your code. Follow the best practices by titling your script and using \# comments to explain your steps. This code should be clean. I should be able to run your code to verify that the code produces the answers you write down.
  - A Word document / Google Docs document or pdf with answers to the written questions (Problems 3-6 below). This document should also have a title with your name on it.
      + You may also alternatively submit a compiled RMarkdown document. We will discuss what RMarkdown is during class.

***Assignment Exercises***

  1. Create an R script saved as ``LastnameSetup1.R" (use your last name). Within the R script, follow the example from  this handout and title the script.
  2. Set your working directory, and include the file pathway (within `setwd()`) at the top of your .R script.
  3. Do the calculation 8 + 3 - 2 in R. Store it as an object with an informative name. Report the answer.
  4. Do the calculation 5 x 3 in R. Store it as an object with an informative name. Report the answer.
  5. Add these two calculations together. Note: do this by adding together the objects you created, not the underlying raw calculations. Report the answer.
  6.  Write down how you will complete your R assignments this semester. For example, if you have a personal laptop with R and RStudio on it, you will simply write "I will use my personal laptop." If you don't have a personal computer or laptop, please indicate where on campus or off-campus you will have regular access to a computer with R/RStudio to do your work. It is essential that you have regular access to a computer so that you will not fall behind in this course.
  7. Navigate to the course Piazza site and post a message. This can be as simple as "hello" or a reply to another person's post. (No need to report this in your submission.)

## R Markdown

An R Markdown document, which you can create in RStudio, allows you to weave together regular text, R code, and the output of R code in the same document. This can be very convenient when conducting data analysis because it allows you more space to explain what you are doing in each step. It can also be an effective platform for writing a report on a data analysis, similar to what you do when you write up a problem set.

***Note: RMarkdown is not required for this course. It is up to you if you would like to write your problem sets in RMarkdown***

R Markdown documents can be "compiled" into html, pdf, or docx documents. Below is an example of what a compiled html file looks like.

  - Note that the image has both written text and a gray chunk, within which there is some R code, as well as the output of the R code (e.g., the number 8 and the image of the histogram plot)

<center> ![](images/rmarkdownscreenshot.png){width=60%}</center>

We say this is a "compiled" RMarkdown document because it differs from the raw version of the file, which is a .Rmd file format. Below is an example of what the raw .Rmd version looks like, compared to the compiled html version.

![](images/rmarkdownraw.png){width=45%} ![](images/rmarkdownscreenshot.png){width=40%}


### How to get setup in RMarkdown

Just like with a regular R script, to work in RMarkdown, you will open up RStudio.

The **first time** you will be working in RMarkdown, you will want to install two packages: `rmarkdown` and `knitr`. You can do this in the Console window in RStudio.

Type the following into the Console window and hit enter/return.

```{r, eval=F}
install.packages("rmarkdown")
install.packages("knitr")
```

Once you have those installed, now, each time you want to create an RMarkdown document, you will open up a .Rmd R Markdown file and get to work.

  1. Go to File -> New File -> R Markdown in RStudio
      - Alternatively, you can click the green + symbol at the top left of your RStudio window
  2. This should open up a window with several options, similar to the image below
      - Create an informative title and change the author name to match your own
      - For now, we will keep the file type as html. In the future, you can create pdf or .doc documents. However, these require additional programs installed on your computer.

![](images/rmarkdownnewfile.png)


  3. After you hit "OK" a new .Rmd script file will open in your top-left window with some template language and code chunks, similar to the image below. 
  
![](images/rmarkdowntemplate.png)
  
  4. ***Save as .Rmd file.*** Save the file by going to "File -> Save as" in RStudio
      - Give the file an informative name like your LastnamePractice1.Rmd
  5. ***Key Components.*** Now you are ready to work within the Rmd script file. We will point to four basic components of this file, and you can build your knowledge of RMarkdown from there.
      1. The top part bracketed by `---` on top and bottom is the YAML component. This tells RStudio the pertinent information about how to "compile" the Rmd file. Most of the time you can leave this alone, but you can always edit the title, author, or date as you wish.
      2. The next component are the global options for the document. It is conveniently labeled "setup." By default what this is saying is that the compiled version will "echo" (i.e., display all code chunks and output) unless you specifically specify otherwise. For example, note that it says `include = FALSE` for the setup chunk. That setting means that this code chunk will "run" but it will not appear in the nicely compiled .html file. Most of the time you will not need to edit those settings.
      3. The third component I want to bring attention to is the body text. The \# symbol in RMarkdown is used to indicate that you have a new section of the document. For example, in the compiled images at the beginning, this resulted in the text being larger and bolded when it said "Problem 2." In addition to just using a single \#, using \#\# or \#\#\# can indicate subsections or subsubsections. Other than that symbol, you can generally write text just as you would in any word processing program, with some exceptions, such as how to make text bold or italicized. (See bottom of section for resources on the Markdown language.)
      4. The final component I want to call attention to are the other main body code chunks. These are specific parts of the document where you want to create a mini R script. To create these, you can simply click the + C symbol toward the top of the top left window of RStudio and indicate you want an R chunk.
      
      <center>
![](images/rmarkdownnewchunk.png){width=20%}</center>
        - For example, in the image above, there is an R code chunk labeled `cars`. The `cars` component is just a label for the code chunk. Labeling code chunks is not necessary. By default, a new R code chunk will just have `r` in the brackets, and that is sufficient.
    
  6. ***Writing R Code.*** Within a code chunk, you can type R code just like you would in any R script. To run ("execute") the R code, you can run a single line the exact same way you do in a regular R script by moving the cursor to the end of a line of code or highlighting a portion of code and hitting "Run." However, in RMarkdown, you also have the option of running an entire code chunk at once by hitting the green triangle at the top-right of a given code chunk.
    
![](images/codechunkexample.png){width=70%}

  7. ***Knitting the document.*** Once you have added a code chunk and/or some text, you are ready to compile or "Knit" the document. This is what generates the .html document.
      - To do so, click on the Knit button toward the top of the top-left window of Rstudio. After a few moments, this should open up a preview window displaying the compiled html file. 
      - It will also save an actual .html file in your working directory (the same location on your computer where you have saved the .Rmd file)
      - Try to locate this compiled .html file on your computer and open it. For most computers, .html files will open in your default web browser, such as Google Chrome or Safari. 
      - This step is a common place where errors are detected and generated. Sometimes the compiling process fails due to errors in the R code in your code chunks or an error in the Markdown syntax. If your document fails to knit, the next step is to try to troubleshoot the error messages the compiling process generates. The best way to reduce and more easily detect errors is to "knit as you go." Try to knit your document after each chunk of code you create. 

### Additional RMarkdown resources

Here are a few additional resources for working with RMarkdown.

  - This [website](https://monashbioinformaticsplatform.github.io/2017-11-16-open-science-training/topics/rmarkdown.html) provides some basic syntax for the Markdown language, such as how to display bulleted lists and how to bold or italicize text.
  - This [page](https://rpubs.com/brandonkopp/RMarkdown) walks through the setup of RMarkdown documents similar to what the course notes just did. This provides a second set of instructions and additional examples of settings you can use to customize your RMarkdown output (e.g., how large figures are when they are displayed).
  - This [page](https://rmarkdown.rstudio.com/articles_intro.html) talks more about compiling aka rendering aka knitting Rmd documents into different formats, such as html, pdf, or Word doc files.
  

See the course Canvas page for additional templates for working with RMarkdown in problem sets.


<!--chapter:end:index.Rmd-->


# Description {#description}

What are things we want to describe in political science?

  - Unemployment rate, GDP
  - Voter turnout, vote share for a party in an election 
  - Percentage of women in the labor force
  - Poverty rates over time

What else? What does description help us achieve?

  - Identify tendencies
  - Identify patterns or trends
  - Identify relationships between two or more factors
  - Help us generalize from anecdotes, what is common vs. what is uncommon?
  - Diagnose demand, needs, potential problems, likely outcomes 
  
Generate ideas for other goals, such as explanation and prediction

## Process of Describing

How do we go about a descriptive quantitative analysis?
  
  1. Substantive Expertise: Start with a topic, puzzle, or question (e.g., How is the economy doing?)
  2. Find outcome data relevant to that question (e.g., GDP)
      - Start from a concept: what we want to describe (i.e., health of the economy)
      - Move toward an "operationalization" (i.e., a way to measure it)
      - Easy! except... social science is messy. Our concepts are rich, while
our measures may be very narrow or concrete.
        + For example, GDP is one way to measure economic health, but is it
the only measure?
        + Choose measures based on validity, reliability, cost
  3. Find multiple relevant units or "data points"
      - E.g., Multiple years of data (e.g., U.S., from 1900 to 2020) 
      - E.g., Multiple countries from one year (e.g., U.S. to Germany to other
countries)
  4. Summarize the data to help answer the question 
  
### Example Process

  1. How is the economy doing?
  2. Find outcome data relevant to that question 
      - Let's ask people
  3. Find multiple relevant units or data points
      - We will ask several people. Each person will be a data point.
  4. Summarize the data
      - Let's take the mean

![](images/economysurvey.png){width=50%}

How would you summarize information in explaining it to another person? You would probably want to describe how most people feel about the economy. In other words, you would describe the "central tendency" of people's responses (the central tendency of the data).

## Summarizing univariate data

For a video explainer of the code in this section, see below. The video only discusses the code. Use the notes and lecture discussion for additional context. (Via youtube, you can speed up the playback to 1.5 or 2x speed.)

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library("vembedr")
library(knitr)

embed_url("https://www.youtube.com/watch?v=80tbdiWuljc")
```


Univariate data refers to data coming from one "variable," where a variable captures the values of a changing characteristic.

Our set of values is Outcome = \{0,0,0,0,1,1,0,1,0,1\}.

  - We will call this a vector of values, where a vector is just a collection of things.
  - Because our vector contains only numbers, we will call it a *numeric* vector.
  - Each value can be indexed by `i`, denoting the position of the value in the
  - For example, Jesse is in position `i=10` of the vector, and his value is 1

We can create vectors in R by using `c()` and assigning `<-` it to an object we will call `Outcome`.

```{r}
Outcome <- c(0,0,0,0,1,1,0,1,0,1) # Use commas to separate values
```


We can extract a particular value within our vector using brackets

```{r}
Outcome[10]
```

We can label our outcomes using `names()`

```{r}
names(Outcome) <-c("Joe","Sally", "Trevor", "Emily", "Mark",
                   "Sarah Jane", "Stacey", "Steve", "Phoebe", "Jesse")
Outcome[10]
```


We can overwrite whole vectors or values within a vector

```{r}
Outcome <- c(5,0,2, 6,1,1, 7, 8, 0, 1) # oops we put the wrong numbers
Outcome
Outcome <- c(0,0,0,0,1,1,0,1,0,1) # no problem, just overwrite it
Outcome
```

Oops we accidentally type a 0 for Jesse.

```{r}
Outcome <- c(0,0,0,0,1,1,0,1,0,0) # oops typo for Jesse
Outcome
Outcome[10] <- 1 # no prob bob. Assign a 1 in position 10
Outcome
```


Vectors do not have to be numeric. Character vectors contain a collection of words and phrases. In R, we use quotations around character values

Example: let's create a vector of names that we will call `People`.

```{r}
People <- c("Joe","Sally", "Trevor", "Emily", "Mark", "Sarah Jane", "Stacey", "Steve", "Phoebe", "Jesse")
People[10]
```

We can use the R function `class()` to tell us the type of object we have.

```{r}
class(Outcome)
class(People)
```

## Functions to summarize univariate data

For univariate data, often we are interested in describing the range of the values and their central tendency.

  - range: the minimum (`min()`) and maximum (`max()`) values
  - mean: the average value (`mean()`)

The average is the sum of the values divided by the number of values:

$\bar{X} = \frac{\text{sum of values}}{\text{number of values}} = \frac{x_1 + x_2 + ... + x_N}{N}=\frac{1}{N}\sum_{i=1}^{i=N} x_i$


Let's do this in R for our set of 10 values

```{r}
(0 + 0 + 0 + 0 + 1 + 1 + 0 + 1 + 0 + 1)/10
```

The average outcome is .4. Note: when a variable contains only 0's and 1's its mean is the proportion of 1's. 40\% of people think the economy is doing well. 


### Using functions in R (overview)

A function is an action(s) that you request R to perform on an object or set of objects. For example, we will use the `mean()` function to ask R to take the mean or "average" of a vector.

  - Inside the function you place inputs or "arguments."


```{r}
mean(Outcome)
```

R also has functions that take the sum `sum()` of a vector of values.

```{r}
sumofvalues <- sum(Outcome)
```

And that count the total number of values or "length" `length()` of the vector.

```{r}
numberofvalues <- length(Outcome)
```

Note that the below is also equivalent to the mean

```{r}
sumofvalues / numberofvalues
```

Returning to our example, we found that 40\% of people surveyed thought the economy was doing well. Surveying people about their opinions on how the country doing is a common way that social scientists use description. We could extend this exercise in many ways going forward, even with the same question.

  - Start with a question: How is the economy doing?
  - Let's find a measure: Ask people if the economy is doing well.
  - Find data points: Multiple people (we could stop there with the average!), or add more variables:
      + Across time: Survey people across multiple years
      + Across type of people: Survey different partisan groups

These types of survey trends are often used by news organizations and public opinion organizations like, Gallup.

![](images/economyconf.png){width=70%}


This was just a first example of description in political science. There are many other ways to describe how the economy is doing and many other topics we might want to describe in politics. 


## Loading data into R

For this section, our motivating example will be methods to measure voter turnout in the United States.

Describing voter turnout

  - What is a typical level of voter turnout?
  - How has turnout changed over time?
  - Is turnout higher in presidential years or in midterm years?

How can we measure turnout? Think about the validity, reliability, and cost of different approaches.

Example: Dataset on Voter Turnout in the U.S. across multiple years

![](images/turnoutframe.png){width=80%}

In this dataset, each row is an election year. Each column contains information about the population, potential voters, or voter turnout. These will help us compute the turnout rate in a given year. To work with this dataset, we need to load it into R.


### Working with datasets in R

For a video explainer of the code in this section, see below. The video only discusses the code. Use the notes and lecture discussion for additional context. (Via youtube, you can speed up the playback to 1.5 or 2x speed.)

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library("vembedr")
library(knitr)

embed_url("https://www.youtube.com/watch?v=rm_g0rrglEQ")
```


Often the variables we care about are stored inside of rectangular datasets

  - These have a number of rows `nrow()` and columns `ncol()`
  - Each row is an "observation," representing the information collected from an individual or entity
  - Each column is a variable, representing a changing characteristic across multiple observations
  

When we import a dataset into R, we have a few options.

Option 1: Download dataset to your computer

  - Move the dataset to your working directory
  - Identify the file type (e.g., csv, dta, RData, txt)
  - Pick the appropriate R function to match the type (e.g., `read.csv(), read.dta(), load(), read.table()`)
  - Assign the dataset to an object. This object will now be `class()` of `data.frame`

```{r, eval=F}
turnout <- read.csv("turnout.csv")
```


Option 2: Read file from a url provided
  
  - Need an active internet connection for this to work
  - URL generally must be public
  - Include the url inside the function used to read the data

```{r}
turnout <- read.csv("https://raw.githubusercontent.com/ktmccabe/teachingdata/main/turnout.csv")
```

```{r}
class(turnout)
```

You can also open up a window to view the data:
```{r, eval=FALSE}
View(turnout)
```

### Measuring the Turnout in the US Elections


Relevant questions with voter turnout

  - What is a typical level of voter turnout? 
  - Is turnout higher in presidential years or in midterm years?
  - Is turnout higher or lower based on voting-eligible (VEP) or voting-age (VAP) populations? 
We have a lot of people who are citizens 18 and older who are ineligible to vote. This makes the VEP denominator smaller than the VAP.

Voter Turnout in the U.S.

  - Numerator: `total`: Total votes cast (in thousands)
  - Denominator:
      - VAP: (voting-age population) from Census
      - VEP (voting-eligible population) VEP = VAP + overseas voters - ineligible voters

  - Additional Variables and Descriptions
      - `year`: election year 
      - `ANES`: ANES self-reported estimated turnout rate 
      - `VEP`: Voting Eligible Population (in thousands) 
      - `VAP`: Voting Age Population (in thousands) 
      - `total`: total ballots cast for highest office (in thousands) 
      - `felons`: total ineligible felons (in thousands) 
      - `noncitizens`: total non-citizens (in thousands) 
      - `overseas`: total eligible overseas voters (in thousands)
      - `osvoters`: total ballots counted by overseas voters (in thousands) 


### Getting to know your data


```{r}
## How many observations (the rows)?
nrow(turnout)

## How many variables (the columns)?
ncol(turnout)

## What are the variable names?
names(turnout)

## Show the first six rows
head(turnout)
```


Extract a particular column (vector) from the data using the \$.
```{r}
turnout$year
```

Extract the 10th year. Just like before! We use 10 to indicate the value of the `year` column in position (row 10) of the data.

```{r}
turnout$year[10]
```


We can take the `mean()` of a particular column, too. Let's take it of the total number of voters.

```{r}
mean(turnout$total)
```

And get the `class()` (Note: integer is just a type of numeric variable)

```{r}
class(turnout$total)
```


We can also use brackets in the full data frame, but because our data frame has BOTH rows and columns, we cannot just supply one position `i`. Instead, we have to tell R which row AND which column by using a comma between the positions.

```{r}
turnout[1,2] # value in row 1, column 2
```

We can use the column name instead

```{r}
turnout[1, "VEP"]
```

If we leave the second entry blank, it will return all columns for the specified row

```{r}
turnout[1,] # All variable values for row 1
```

The opposite is true if we leave the first entry blank.
```{r}
turnout[,2] # VEP for all rows
```

## Comparing VEP and VAP turnout

### Creating new variables in R

Let's create a new variable that is VAP that adds overseas voters.

```{r}
# Use $ to add a new variable (i.e., column) to a dataframe
turnout$VAPplusoverseas <- turnout$VAP + turnout$overseas
```

Under the hood, what this is doing is taking each value of `turnout$VAP` and adding it to its corresponding values of `turnout$overseas`.

And, yes, this new variable shows up as a new column in `turnout`. Go ahead, `View()` it

```{r, eval=F}
View(turnout)
```

This does not change the underlying `turnout.csv` file, only the `turnout data.frame` we are working with in the current R session.

  - This is an advantage of using an R script. 
  - You don't have to worry about overwriting/messing up the raw data. 
  - You start from the original raw data when you load {\tt turnout.csv}, and then everything else is done within R.


This is our new denominator. Now we can calculate turnout based on this denominator.
```{r}
turnout$newVAPturnout <- turnout$total / turnout$VAPplusoverseas
```

Just like with adding two vectors, when we divide, each value in the first vector is divided by its corresponding value in the second vector.

```{r}
turnout$newVAPturnout
```


Let's calculate the VEP turnout rate and turn it into a percentage. This time, we do it in one step.

  -  (total votes / VEP) $\times$ 100:

```{r}
turnout$newVEPturnout <- (turnout$total / turnout$VEP) * 100
turnout$newVEPturnout
```

Let's change it from a proportion to a percentage. How? Multiply each value of `turnout$newVAP` by 100

```{r}
turnout$newVAPturnout <- turnout$newVAPturnout * 100
```

This multiplies each number within the vector by 100. 

```{r}
turnout$newVAPturnout
```


What is typical turnout?

```{r}
mean(turnout$newVAPturnout)

mean(turnout$newVEPturnout)
```

We find that turnout based on the voting age population is lower than turnout based on the voting eligible population. This is a pattern that political scientists have examined, going back several decades. For example, in a 2001 article McDonald and Popkin show that is it the ineligible population that grew from the 1970s onward and not the population of people who simply prefer not to vote. (See more [here](https://www.jstor.org/stable/3117725).)

![McDonald and Popkin 2001](images/VEP.png)

## Comparing Presidential vs. Midterm turnout

How does turnout compare in presidential vs. midterm years? Sometimes using a single summary of turnout may obscure important underlying differences in the data. To detect these differences, we may want to summarize different parts of the data.

Oh dear. We need to extract specific years from the turnout data frame. Which rows contain the years we want?

```{r}
turnout$year
```

Ok: rows 1,3,5,7,9,11,13,14 are the presidential. And rows 2,4,6,8,10,12 are midterms.

```{r}
## we can extract all of these at once by using c()
turnout$year[c(1,3,5,7,9,11,13,14)] # presidential
```

Let's take the mean VEP turnout for presidential years.

```{r}
mean(turnout$newVEPturnout[c(1,3,5,7,9,11,13,14)])
```

Let's take the mean VEP turnout for midterm years.

```{r}
mean(turnout$newVEPturnout[c(2,4,6,8,10,12)])
```


Let's take the difference by storing each mean and then subtracting

```{r}
mean.VEP.pres <- mean(turnout$newVEPturnout[c(1,3,5,7,9,11,13,14)])
mean.VEP.mid <- mean(turnout$newVEPturnout[c(2,4,6,8,10,12)])
mean.VEP.pres -  mean.VEP.mid
```

Presidential turnout, on average, is higher than midterm turnout.

### R shortcut for writing vectors

Sometimes we write numbers that are in a predictable sequence (e.g., 1,2,3,4,5). In R, we have functions that prevent us from having to type each number when this is the case.

```{r}
c(1,2,3,4,5) # is equivalent to:
1:5 # is equivalent to:
seq(from = 1, to = 5, by = 1)
```

We can use the last one to our advantage to extract the midterm years, which go by 2

```{r}
mean(turnout$newVEPturnout[c(2,4,6,8,10,12)]) # is the same as

mean(turnout$newVEPturnout[seq(2, 12, 2)])
```

Not a big deal now, but imagine if you had to write 100 numbers or 1 MILLION NUMBERS!

In this section, we have described voter turnout using multiple measures and types of elections. There are several other questions that political scientists may be interested in when it comes to voter turnout.

For example, Texas and more than a dozen other states have passed new laws that change voting procedures in elections. What effect will these have on voter turnout? In the next section, we start to examine how to evaluate causal claims.

![](images/texaslaw.png){width=60%}




<!--chapter:end:02-Description.Rmd-->

# Causation with Experiments {#causation1}

Recall that we said, four primary goals of social science include:

  - **Describe** and measure
      + Has the U.S. population increased?
  - **Explain**, evaluate, and recommend (study of causation)
      + Does expanding Medicaid improve health outcomes?
  - **Predict**
      + Who will win the next election?
  - **Discover**
      + How do policies diffuse across states?

In this section, we start to explore the goal of explanation--making causal claims.

## What separates causation from correlation?

Here's an example. In 2016, researchers at the [NY Times](https://www.nytimes.com/interactive/2016/12/26/upshot/duck-dynasty-vs-modern-family-television-maps.html) noticed that areas in the country where the television show *Duck Dynasty* was popular also tended to support Donald Trump at higher rates. 

![](images/duckdynasty.png)


If we put our social scientist hat on, we might want to distinguish whether this is a causal or, more likely, just a correlational relationship:

  - Correlation: Areas that watch Duck Dynasty are more likely to support Trump (degree to which two  variables "move together")
  - Causality: Watching Duck Dynasty (vs. not watching) increases your support of Trump. 

Causal Question: Does the manipulation of one factor (the treatment), (holding everything else constant), cause a change in an outcome?

### Potential Outcomes Framework

When studying causal relationships, we distinguish two concepts:

  - treatment: variable whose change may produce a change in the outcome 
  - outcome ($Y$): what may change as a result

We imagine two states of the world or "potential outcomes."

  - $Y(1)$: the outcome if the treatment is administered 
  - $Y(0)$: the outcome if the treatment is NOT administered (or maybe something else is)

Example: How does voter turnout ($Y$) change as a result of varying whether someone receives a mail-in ballot (the treatment)?

  - $Y(\text{sent a mail-in ballot})$: do you vote or not
  - $Y(\text{not sent a mail-in ballot})$: do you vote or not 
  
We compare your likelihood of turning out to vote in a world where you did receive a mail-in ballot vs. a counterfactual state of the world in which you did not receive a mail-in ballot, generally assuming that this is the only thing that is different between these two potential states of the world. 

In many cases in social science, we might start by observing some connection in the real world (a factual observation). To make a causal claim, we then have to imagine what that counterfactual state of the world would be. Examples:  

  - Causal Question: Does the minimum wage increase the unemployment rate?
      + (Hypothetical) Factual: An unemployment rate went up after the minimum wage increased
      + Implied Counterfactual: Would the unemployment rate have gone up, had the minimum wage increase not occurred?
  - Causal Question: Does race affect one's job prospects?
      + (Hypothetical) Factual: Jamal applied for a job but did not get it
      + Implied Counterfactual: Would Jamal have gotten a job if he were white?


We use causal logic all of the time outside of social science. 


For example, many viewers get angry after watching the movie [*Titanic*](https://www.youtube.com/watch?v=3gK_2XdjOdY) because they believe Jack did not have to die. We can place their claims in our causal framework: 

![](images/titanicdoor.jpeg)

  - Outcome: Jack Surviving the Titanic
  - Potential Outcomes in two states of the world
      + Rose did not share the floating door, and Jack died.
      + Counterfactual question: If Rose had shared the floating door, would Jack have lived?



In [*Bit by Bit*](https://www.bitbybitbook.com/en/1st-ed/running-experiments/), Matt Salganik notes that sometimes cause-and-effect questions are implicit. For example, in more general questions about maximization of some performance metric, we might want to compare several alternatives: 

The question "What color should the donate button be on an NGO's website?" is really lots of questions about the effect of different button colors on donations.

  - Factual: A voter donates some amount with a black button
  - Counterfactual: What would a voter donate if the button were blue?
  - Counterfactual: What would a voter donate if the button were red?

What other causal questions might social scientists or data scientists ask?

### Causal Effects

When we are conducting a causal analysis, we will want to estimate a causal effect.

A causal effect is the change in the outcome Y that is caused by a change in the treatment variable.
  
  - $Y(1) - Y(0)$ = causal effect or "treatment effect"
      + e.g., Donation if contacted - Donation if not contacted


We often want to know the **average treatment effect** in some population, not just the causal effect for a single individual. Here, we might ask, on average, how much would our outcome change if our units were treated instead of untreated. To do so, we simply sum up all of the causal effects and divide them by the number of units in our population.

  - $\frac{1}{N} \sum_{i=1}^N (Y_i (1)-Y_i (0))$ = "average treatment effect" (ATE)
      + e.g., Average donations if contacted - Average donations if not contacted


### Fundamental Problem of Causal Inference

The problem: Fundamental Problem of Causal Inference

What makes the evaluation of causal claims difficult, is that in the real world, we suffer from the fundamental problem of causal inference:

  - For any individual, we only get to see (observe) the result from one state of the world
      + This makes that subtraction of potential outcomes impossible.

(Unless we are in [Groundhog Day](https://www.youtube.com/watch?v=5E0M6Rh9qpg) or *Russian Doll*)

## Randomized Controlled Trials

One approach for addressing the fundamental problem of causal inference is to simulate two potential states of the world through random assignment: Randomized Controlled Trials / Experiments

Experiments approximate factual vs. counterfactual comparison
  
  - We randomly assign one group to receive a "treatment" and another not to receive a treatment (the control)
  - When treatment assignment is **randomized**, the only thing that distinguishes the treatment group from the control group, besides the treatment itself, is chance.

This allows us to compare the average outcomes between groups in order to estimate our causal effects (more on this below).

### Experiments: Why Randomize?

Randomization is essential for being able to "identify" and isolate the causal effect of the treatment on the outcome. Without randomization, there may be several reasons why two groups differ beyond the treatment of interest.

For example, if we randomly assigned half of Rutgers seniors to watch the movie *Groundhog Day* and half to watch *Parasite* we would expect the groups to have about equal proportions of female students, average age, racial composition, majors, etc.
  
  - (If we didn't randomly assign, and just let people "select" into watching a particular movie, the groups could look very different.)

But because we randomized assignment, on average, we'd expect the two groups to be identical except for the treatment-- in this case, which movie they watched.

  - Great news! This means any differences in the outcomes between the two groups can be attributed to the treatment. So if we wanted to see if *Parasite* leads people to have nightmares about people living in their basements, we could compare the average number of reported nightmares between the seniors that watched *Parasite* vs. *Groundhog Day* 
  

### Experiments: How to Analyze

Difference in Means: We compare each group's average outcome by subtracting one from the other to estimate the average treatment effect (ATE) aka the average causal effect of the treatment.

  - $\widehat{ATE} = \bar{Y}(treatment) - \bar{Y}(control)$

This is an estimate of, on average, how much our outcome would change if units went from being untreated to treated. 

  - E.g., on average how much a person donates to a campaign if contacted by phone compared to if not contacted by phone.



### Ingredients of an Experiment

From [*Bit by Bit*](https://www.bitbybitbook.com/en/1st-ed/running-experiments/)

![](images/bitbybitexp.png)

For every experiment, you should be able to

  - State the causal question or relationship of interest
  - Describe how the experiment will be implemented (e.g., recruitment of subjects)
  - Identify and describe the randomization into treatment group(s) and control group and what happens in each group
  - Identify the outcome of interest, how it is measured
  - Evaluate the relevant comparison

We will turn to an example in the next section.

## Application: Is there racial discrimination in the labor market?

Marianne Bertrand and Sendhil Mullainathan. 2004. "Are Emily and Greg more
employable than Lakisha and Jamal? A field experiment on labor market discrimination."


"We perform a field experiment to measure racial discrimination in the labor market. We respond with fictitious resumes to help-wanted ads in Boston and Chicago newspapers." 

  - Recruitment: Construct resumes to send to ads 
  - Randomization:  To manipulate perception of race, each resume is (randomly) assigned
  - Treatment: either a very African American sounding name 
  - Control: or a very White sounding name
  - Outcome: Does the resume receive a callback?
  - Comparison: Callback rates for African American (sounding) names vs. White (sounding) names (the difference in means between groups)

*For a video explainer of the code in this section, see below. The video only discusses the code. Use the notes and lecture discussion for additional context. (Via youtube, you can speed up the playback to 1.5 or 2x speed.)*

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library("vembedr")
library(knitr)

embed_url("https://www.youtube.com/watch?v=LeJkRydMruM")
```

Let's load the data. Note: When we have variables that are text-based categories, we may want to tell R to treat these "strings" of text information as factor variables, a particular type of variable that represents data as a set of nominal (unordered) or ordinal (ordered) categories. We do this with the `stringsAsFactors` argument.

```{r, eval=F}
resume <- read.csv("resume.csv", stringsAsFactors = T)
```

```{r}
resume <- read.csv("https://raw.githubusercontent.com/ktmccabe/teachingdata/main/resume.csv",
                   stringsAsFactors = T)
```

Variables and Description
  
  - `firstname`: first name of the fictitious job applicant 
  - `sex`: sex of applicant (female or male) 
  - `race`:  race of applicant (black or white) 
  - `call`: whether a callback was made (1 = yes, 0 = no) 
  

The data contain 4870 resumes and 4 variables.
```{r}
nrow(resume) # number of rows
ncol(resume) # number of columns
dim(resume) # number of rows and columns
```



Note: These data look a little different from what we used last week. For example, the `sex` and `race` variables contain words, not numbers.

```{r}
head(resume)
```

### Variable classes

We can check the class of each variable: Look, we have a new type, a "factor" variable.

```{r}
class(resume$firstname)
class(resume$sex)
class(resume$race)
class(resume$call)
```


We have now encountered `numeric, character`, and `factor` vectors and/or variables in R. Note: This is simply how R understands them. Sometimes R can get it wrong. For example, if we write:

```{r}
somenumbers <- c("1", "3", "4")
class(somenumbers)
```

Because we put our numbers in quotation marks, R thinks the values in `somenumbers` are text. The number "3" might as well be the word "blue" for all R knows. Fortunately, we can easily switch between classes.

```{r}
somenumbers <- as.numeric(somenumbers)
class(somenumbers)
```

Here,  we used `as.numeric()` to overwrite and change the character vector into a numeric vector. 

Rules of Thumb
  
  - Usually, we want `character` variables to store text (e.g., open-ended survey responses)
  - We want `numeric` variables to store numbers.
  - Usually, we want `factor` variables to store categories. 
      + Within R, factor variables assign a number to each category, which is given a label or `level` in the form of text.
      + Categories might be ordinal or "ordered" (e.g., Very likely, Somewhat likely, Not likely) or
      + Unordered (e.g., "male", "female")
      + R won't know if a factor variable is ordered or unordered. Alas, we have to be smarter than R.
      + R might think you have a character variable when you want it to be a factor or the reverse. 
          - That's when `as.factor()` and `as.character()` are useful. 
  - Always check `class()` to find out the variable type


## Making tables

A nice thing about numeric and factor variables is we can use the `table` command to see how many observations in our data fall into each category or numerical value.

```{r}
## Example: how many black vs. white sounding resumes
table(resume$race)
```

As mentioned, `factor` variables have levels:

```{r}
levels(resume$race)
```

### Crosstabulation

We can also use the `table` command to show a crosstabulation: a table that displays the frequency of observations across two variables.

```{r}
## Example: how many black vs. white sounding resumes by call backs
## We can label the two dimensions of the table with the =
table(calledback = resume$call, race = resume$race)
```


Sometimes we will want to show the proportion instead of the frequency using `prop.table`

```{r}
## Example: proportion black vs. white sounding resumes by call backs
## Convert to proportion
prop.table(table(calledback = resume$call, race = resume$race), margin = 2) # 1 for row sum, 2 for col
```

***How can we interpret this crosstabulation? It should let us see the causal effect-- the callback rate for each group***

## Conditional Means

Another thing we can do with factor variables is to find how the average of one variable (e.g., our outcome- the callback rate) varies across different categories of our factor variable. For this, we use `tapply()`.

```{r}
## take the mean of input1 by categories of input2
## mean of call by race
tapply(resume$call, INDEX=resume$race, mean)
```


## Relational Operators in R

Goal: Compare callback rates for white sounding names to black sounding names, so we need to be able to filter by race. 

Good news: We have several relational operators in R that evaluate logical statements:
  
  -  `==, <, >, <=, >=, !=`
  - We have a statement and R evaluates it as `TRUE` or `FALSE`

```{r, eval=F}
## for each observation, does the value of race equal "black"?
resume$race == "black"
```

By putting this logical statement within `[ ]`, we are asking R to take the `mean()` of the variable `resume$call` for the subset of observations for which this logical statement is `TRUE`.

```{r}
mean(resume$call[resume$race == "black"])
```


Ultimately, each of these paths has led us to a place where we can estimate the average treatment effect by calculation the difference in means: the difference in callback rates for black and white applicants.

We said the ATE = $\bar{Y}(treatment) - \bar{Y}(control)$ 

```{r}
ate <- mean(resume$call[resume$race == "black"]) - 
  mean(resume$call[resume$race == "white"])
ate
```

How can we interpret this? Do white applicants have an advantage?

## Subsetting data in R

Subsetting Dataframes in R

Maybe we are interested in differences in callbacks for females. One approach for looking at the treatment effect for female applicants, only, is to subset our data to include only female names.

  - To do this, we will  assign a new `data.frame` object that keeps only those rows where `sex == "female"` and retains all columns 
  - Below are two approaches for this subsetting, one that uses brackets and one that uses the `subset` function

```{r}
## option one
females <- resume[resume$sex == "female", ]
## option two using subset()- preferred
females <- subset(resume, sex == "female")
```

Now that we have subset the data, this simplifies estimating the ATE for female applicants only.

We said the ATE = $\bar{Y}(treatment) - \bar{Y}(control)$

```{r}
ate.females <- mean(females$call[females$race == "black"]) -
  mean(females$call[females$race == "white"])
ate.females
```


### Getting Booooooooolean

We can make this slightly more complex by adding more criteria. Let's say we wanted to know the callback rates for just female black (sounding) names.

  - R allows use to use `&` (and) and `|` (or)

```{r}
femaleblack <- subset(resume, sex == "female" & race == "black")
```

We could now find the callback rate for Black females using the tools from above:

```{r}
mean(femaleblack$call)
```


## Creating New Variables using Conditional statements

We can instead create a new variable in our main dataframe. Let's make a variable that takes the value 1 if a name is female and black sounding and 0, otherwise

```{r}
# Initialize a new variable called femaleblackname
resume$femaleblackname <- NA
# Assign a 1 to our new variable where sex is female and race is black
resume$femaleblackname[resume$sex == "female" & resume$race == "black"] <- 1
# Assign a 0 if sex is not female OR if race is not black
resume$femaleblackname[resume$sex != "female" | resume$race != "black"] <- 0
```


We can check our work
```{r}
table(name = resume$firstname, femaleblack = resume$femaleblackname)
```


Let's say we wanted to  know the callback rates for just female black (sounding) names.

```{r}
mean(femaleblack$call)

mean(resume$call[resume$femaleblackname == 1])

```
BINGO: two ways to do the same thing.

### ifelse statements

Remember how we created the variable `femaleblack`, well there is another way to do that in R using what are called conditional statements with `ifelse()`.

  - Can be read: If this relational statement is `TRUE`, I assign you A, otherwise I assign you B

```{r}
resume$femaleblackname <- ifelse(resume$sex == "female" &
                                   resume$race == "black", 1, 0)
```

Can be read: If sex is female and race is black, give the observation in the new variable a 1, otherwise give it a 0.


Like most things, we can also get more complicated here. Let's say we wanted to create a variable that indicated both race and sex.

  - Can be read: If this relational statement is `TRUE`, I assign you A, 
  - Otherwise if this second relational statement is `TRUE`, I assign you B,
  - Otherwise if this third relational statement is `TRUE`, I assign you  C,
  - Otherwise I assign you D

```{r}
resume$racesex <- ifelse(resume$sex == "female" &
                                   resume$race == "black", "FemaleBlack", 
                         ifelse(resume$sex == "female" &
                                   resume$race == "white", "FemaleWhite",
                                ifelse(resume$sex == "male" &
                                   resume$race == "white", "MaleWhite", "MaleBlack")))
```
Note: what you assign can be numeric or text.



## Types of Experiments

Experiments can vary:

  - Setting: Lab, Survey, Field
  - Mode: Analog vs. Digital
  - And in Validity
      + Internal: were the processes conducted in a correct, reliable way?
      + External: can we generalize from the experiment to the real world, or would the results change?
      + Context: Would people act the same way outside of the experiment?
      + Recruitment: Are the people in our experiment representative of the people we care about?
      + Construct
          - Treatment: Is the experimental treatment similar to what people see in the real world?
          - Outcome: Is the outcome something we care about in the real world? Are we measuring it in a realistic, accurate way?


Review [*Bit by Bit*](https://www.bitbybitbook.com/en/1st-ed/running-experiments/) chapter 4 for more examples of social science experiments.




<!--chapter:end:03-CausalityI.Rmd-->

# Visualization {#visualization}

In this section, we discuss a set of tools for data visualization in R.

Goals of data visualization

  - Communicate information
      + Transparently (show me the data!)
      + Quickly
      + Simply
      + Accurately
      + And with a little work: beautifully
 
There are many resources for ideas and best practices for data visualization. See [here](https://www.tableau.com/learn/articles/best-data-visualization-blogs) and [here](https://serialmentor.com/dataviz/index.html).

We will cover many types of visuals, each typically designed for a different purpose.

What to communicate?

  - Data summary
      + Central tendency (e.g., mean, median)
      + Spread (e.g., standard deviation, IQR)
  - Comparison
      + e.g., Callback rates for black vs. white sounding names
  - Trend
      + e.g., Economic confidence over time
  - Relationship
      + e.g., Correlation 


## Application: Social Status and Economic Views

We are going to explore different types of visualizations through different social science examples. The first application we visit is a survey experiment.

Thal, A. (2020). The desire for social status and economic conservatism among affluent Americans. American Political Science Review, 114(2), 426-442.

In the experiment, affluent Americans are randomly assigned to encounter Facebook posts in which others broadcast their economic success. These posts are designed in a way that encourages affluent respondents to view economic success as a means of achieving social status.

Causal claims

  - "I expect that exposure to these posts will cause affluent Americans to become more supportive of conservative economic policies." 
  - "I also expect that exposure to these posts will cause especially large increases in economic conservatism among affluent men."


The experiment includes a sample of 2010 affluent Americans-- people who report household incomes in the top 10 percent of the U.S. income distribution.

Experiment Ingredients:

  - Causal Question: Does desire for social status influence economic views of affluent Americans?
  - Recruitment: Ask affluent Americans to take a survey online
  - Randomization: Randomly assign respondents to view different fictional Facebook posts designed to signal different motivations
  - Outcome: an index based on respondents' support for decreasing "taxes on households making \$150,000 or more a year," support for decreasing the "taxes on money people make from selling investments, also referred to as capital gains," and support for decreasing "government regulation of business and industry."
  - Comparison: Average economic views between experimental conditions.

Snapshot of status conditions

![](images/status1.png){width=70%}


Snapshot of Concrete and Placebo comparison conditions

![](images/status2.png){width=70%}


**Can you put this into the potential outcomes framework?**

## Boxplots

For a video explainer of the code for boxplots and barplots, see below. The video only discusses the code. Use the notes and lecture discussion for additional context. (Via youtube, you can speed up the playback to 1.5 or 2x speed.)

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library("vembedr")
library(knitr)

embed_url("https://www.youtube.com/watch?v=QmQr4lfrmUc")
```



Let's load the data! Here, note that the data file is in a .RData format instead of .csv. This means that instead of using `read.csv`, we should use a function to load the data that is suitable for the .RData format. This will be `load`. That function works the following way:


```{r, eval=T, echo=FALSE, include=FALSE}
load("data/status.RData")
```

```{r,eval=F}
load("status.RData")
```

After running the above code, an object will show up in your R environment.

```{r}
head(status)
```

The data include the following variables

  - `condition`: Placebo, Concrete, Self-Esteem, Social Approval, Conspicuous Consumption
  - `gender`: 1= male; 0= otherwise
  - `econcon`: Economic views. Numeric variable from 0 to 1, with higher values reflecting more conservative views



### Data Summary: Boxplot
  
Characterize the distributions of continuous numeric variables at once

  - Features: box, whiskers, outliers
  - We will supply the function with a column in our data, and the boxplot displays the distribution of that variable.

![](images/agebox.png){width=80%}

*Figure from Will Lowe*

Here is an example of the `boxplot` using our `econcon` variable. 

  - We have added a title and y-axis label to the plot through the `main` and `ylab` arguments. Play around with changing the words in those arguments.
  
```{r}
boxplot(status$econcon,
        main="Economic Views in the Survey Sample",
        ylab="Economic Views")
```

After you  execute the plot code, a preview of the plot should appear in the bottom-right window of RStudio.

Boxplots are also useful for data summary across multiple distribution: `boxplot(y ~ x, data = d)`

```{r, fig.width=11}
boxplot(econcon ~ condition, data=status,
        main="Economic Views by Experimental Condition",
        ylab="Economic Views",
        names = c("Placebo", "Concrete", "Conspicuous", 
                  "Self-Esteem", "Social"),
        xlab = "Experimental Condition",
        col = c("red3", rep("dodgerblue", 4)))
```

The additional arguments are just aesthetics. Play around with different settings. 

  - For example, can you change the code to make the first two boxes red? Colors are supplied as a vector using the `col =` argument.
      + To explore colors in R, run this function `colors()` in your R console.


How should we interpret these results? Does status or social approval motivation, specifically, influence economic views? What about other potential motivations?

## Barplots

Comparing frequencies (raw N), proportions, and/or means across categories

```{r, eval=T, echo=F}
valuesbar <- c(20, 40, 50, 10, 60)

namesbar <- c("Car rides \n to Malibu",
              "Strawberry ice cream,\n One spoon for two",
              "Trading jackets",
              "Watching reruns \n of Glee",
              "Being annoying \n Singing in harmony")

barplot(valuesbar,
        names=namesbar,
        cex.names = .6,
        main="Level of deja vu",
        ylab="Avg. Feeling of deja vu",
        cex.lab = .7, 
        col="purple3")
```

We will use the `barplot()` function.

  - In contrast to the boxplot, the barplot function takes a vector of values that will serve as the top of the bars in the plot-- it does not summarize a variable from within the function
      + E.g., we could supply it a set of means to plot, not a raw variable 
  - Many of the other arguments are aesthetics that will give you [deja vu](https://www.youtube.com/watch?v=cii6ruuycQA&ab_channel=OliviaRodrigoVEVO) after working with boxplot.
  - This means that barplots are pretty easy to create in R. We can supply it a short vector of any values (e.g., `valuesbar <- c(20, 40, 50, 10, 60)`), and we could also supply it a vector of any names to label those values. 
      + For real applications, this means we could supply a barplot with the output of a `tapply()` function, a `table()` summarizing a single variable, or a set of `mean()` values we have combined into a vector.


For example, in experiments, we may use barplots to compare the mean from the treatment group(s) $\bar{Y}(1)$ to the control $\bar{Y}(0)$ on some outcome. Let's do it!

  - First, we need the means. Let's find the conditional means of economic views.

```{r}
condmeans <- tapply(status$econcon, status$condition, mean)
condmeans # save as object to supply to the barplot function
```



The first input is the vector of means/proportions/frequency you want to plot.

```{r}
barplot(condmeans,
        ylim =  c(0,1), # y-axis dimensions
        names = c("Placebo", "Concrete", "Conspicuous", 
                  "Self-Esteem", "Social"),
        col = "black", # color of bars
        main = "Mean Economic Views by Condition", # plot title
        cex.main = .8, # size of plot title
        cex.names = .8, # size of name labels
        ylab = "Mean Views", # yaxis label
        cex.lab = .8,# size of yaxis label
        las = 1) # controls angle of axis labels
```

The remaining arguments alter the look of the plot to make it more informative.

  - How could we improve this plot to make the interpretation easier?

### Saving Plots

You can save an image of your plot as a `png()` to your working directory. Place `png()` just before your plot with a name in quotations, and then specify the dimensions. Place `dev.off()` at the bottom.

```{r, eval=F}
png("mybarplot.png", width = 7, height = 4, res=300, units="in")
barplot(condmeans,
        ylim =  c(0,1), # y-axis dimensions
        names = c("Placebo", "Concrete", "Conspicuous", 
                  "Self-Esteem", "Social"),
        col = "black", # color of bars
        main = "Mean Economic Views by Condition", # plot title
        cex.main = .8, # size of plot title
        cex.names = .8, # size of name labels
        ylab = "Mean Views", # yaxis label
        cex.lab = .8,# size of yaxis label
        las = 1) # controls angle of axis labels
dev.off()
```



### Creating New Variables

The author theorizes that social approval, self-esteem, and conspicuous consumption are all elements of "status motivation." We could analyze the results by collapsing them into a single category called "status motivation" and compare it to the other experimental groups.

  - Create a new variable `conditionnew`
  - Code the variable into new categories based on the values in the original `condition` variable
  - Check the class of the new variable and convert if necessary
  - Verify new variable by exploring values


```{r}
status$conditionnew <- NA # create new variable
## Code new variable
status$conditionnew[status$condition == "Placebo"] <- "Placebo"
status$conditionnew[status$condition == "Concrete"] <- "Concrete"
status$conditionnew[status$condition == "Conspicuous Consumption" |
                     status$condition == "Self-Esteem" |  
                      status$condition == "Social Approval"] <- "Status"

# class(status$conditionnew) check the class
status$conditionnew <- as.factor(status$conditionnew) # convert
```


An alternative way to create the new variable is through an `ifelse` statement. 

  - Can be read: If this relational statement is  `TRUE`, I assign you A, otherwise I assign you B
  - This often works best when we change factor variables to character

```{r}
status$conditionnew2 <- as.character(status$condition)
status$conditionnew2 <- ifelse(status$condition == "Conspicuous Consumption" |
                     status$condition == "Self-Esteem" |  
                      status$condition == "Social Approval", 
                     "Status", status$conditionnew2)
status$conditionnew2 <- as.factor(status$conditionnew2)
table(status$conditionnew2)
```


Note: Barplots don't have to display means. We could also display frequencies. For example, let's make a plot of the number of people in each condition using our new variable.

```{r}
freqobs <- table(status$conditionnew)


barplot(freqobs,
        ylim = c(0, 1200),
        col = "black", # color of bars
        main = "Number of People per Condition", # plot title
        cex.main = .8, # size of plot title
        cex.names = .8, # size of name labels
        ylab = "N of Observations", # yaxis label
        cex.lab = .8,# size of yaxis label
        las = 1) # controls angle of axis labels
```


<!--chapter:end:04-Visualization.Rmd-->

